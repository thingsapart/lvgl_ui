import json
import re
import sys
from collections import defaultdict

"""
The JSON output generated by this file provides a comprehensive, high-level translation of the LVGL API. It transforms the flat C-style function list from the source specification into a hierarchical, object-oriented structure that is easier for tools to parse.

Key Sections:
*   **`widgets`**: Details the full widget hierarchy, defining each widget's parent, creation function, methods, and a list of high-level `properties` inferred from C setter functions (e.g., `lv_label_set_text` becomes a `text` property).
*   **`objects`**: Describes non-widget types like `style` and their associated properties and methods, mirroring the structure of `widgets`.
*   **`enums` / `constants`**: Provide exhaustive maps of all enumerated values and global constants.
*   **`functions`**: Contains a complete, flat reference of all raw C function signatures for tooling that requires full API access.
"""

class LVGLApiParser:
    """
    Parses the LVGL API specification JSON and translates it into a more
    structured, hierarchical format suitable for code generators or documentation.
    """

    def __init__(self, api_spec):
        """Initializes the parser with the raw API specification."""
        self.spec = api_spec
        self.result = {
            "constants": {},
            "enums": {},
            "functions": {},
            "widgets": defaultdict(lambda: {"properties": {}, "methods": {}}),
            "objects": defaultdict(lambda: {"properties": {}, "methods": {}}),
        }
        # Pre-populate with known types
        self.widget_types = {'obj'}
        self.object_types = {'style'}
        self.enum_type_names = set()

    def _get_type_str(self, type_info):
        """Recursively builds a string representation of a C type."""
        if not type_info:
            return "unknown"
        if type_info.get('json_type') == 'ret_type':
            return self._get_type_str(type_info.get('type'))
        if type_info.get('name') == 'void' and 'pointer' not in type_info.get('json_type', ''):
            return "void"

        suffix = ""
        current = type_info
        while current.get('json_type') == 'pointer':
            suffix += '*'
            current = current.get('type', {})

        base_name = current.get('name') or current.get('type', {}).get('name') or "anonymous"
        return f"{base_name}{suffix}".strip()

    def _get_property_type(self, func_info):
        """Determines a simplified property type from a setter function's signature."""
        func_name = func_info.get('name', '')
        args = func_info.get('args', [])

        if len(args) < 2:
            return 'unknown'

        # The second argument is usually the value being set.
        val_arg = args[1]
        val_arg_type_str = self._get_type_str(val_arg.get('type'))

        # Return regular type for now, non-simplified
        return val_arg_type_str

        # --- Obsolete for now ---

        # Check subsequent arguments for an animation flag
        has_anim = any(self._get_type_str(arg.get('type')) == 'lv_anim_enable_t' for arg in args[2:])

        prop_type = 'unknown'

        if 'int' in val_arg_type_str:
            prop_type = 'int'
        elif val_arg_type_str == 'lv_coord_t':
            prop_type = 'size'
        elif val_arg_type_str == 'bool':
             prop_type = 'bool'
        elif val_arg_type_str == 'const char*':
            prop_type = 'string'
        elif val_arg_type_str == 'lv_color_t':
            prop_type = 'color'
        elif val_arg_type_str == 'const lv_font_t*':
            prop_type = 'font'
        elif val_arg_type_str in self.enum_type_names or \
             (val_arg_type_str.startswith('lv_') and val_arg_type_str.endswith('_t')):
            prop_type = 'enum'
        elif val_arg_type_str == 'uint8_t':
             prop_type = 'uint8'
        else:
            # Fallback for complex or pointer types
            prop_type = val_arg_type_str

        # Handle special cases
        if func_name == 'lv_obj_add_style':
            return 'style_tuple'
        if has_anim:
            return f"{prop_type}_anim"

        return prop_type

    def _discover_types(self):
        """First pass to identify all enum, widget, and object types."""
        for enum in self.spec.get('enums', []):
            if enum.get('name'):
                self.enum_type_names.add(enum['name'])

        for func in self.spec.get('functions', []):
            name = func.get('name', '')
            if name.endswith('_create'):
                match = re.match(r"lv_(\w+)_create", name)
                if match:
                    self.widget_types.add(match.group(1))
            elif name.endswith('_init'):
                match = re.match(r"lv_(\w+)_init", name)
                if match and match.group(1):
                    # Avoid adding 'mem' as a user-facing object
                    if match.group(1) not in ['mem']:
                        self.object_types.add(match.group(1))

    def _translate_primitives(self):
        """Translate enums, constants, and raw function signatures."""
        # Enums and Constants
        for enum in self.spec.get('enums', []):
            members = {member['name']: member['value'] for member in enum.get('members', [])}
            if enum.get('name'):
                self.result['enums'][enum['name']] = members
            else:
                self.result['constants'].update(members)

        # Macros
        for macro in self.spec.get('macros', []):
            if macro.get('params') is None and macro.get('initializer'):
                 # Sanitize C-style initializers for JSON
                initializer = macro['initializer'].strip().replace("ULL", "").replace("UL", "").replace("U", "")
                initializer = initializer.replace("L", "").replace("LL", "")
                self.result['constants'][macro['name']] = initializer

        # Functions
        for func in self.spec.get('functions', []):
            func_name = func.get('name', '')
            if not func_name: continue

            ret_type_str = self._get_type_str(func.get('type'))
            args_list = []
            if func.get('args'):
                is_void_arg = len(func['args']) == 1 and self._get_type_str(func['args'][0].get('type')) == 'void'
                if not is_void_arg:
                    args_list = [self._get_type_str(arg.get('type')) for arg in func['args']]

            self.result['functions'][func_name] = {
                "return_type": ret_type_str,
                "args": args_list
            }

    def _structure_api(self):
        """Second pass: Organize functions into widget/object properties and methods."""
        # Initialize widget hierarchy
        self.result['widgets']['obj']['inherits'] = None
        for w_name in self.widget_types:
            if w_name != 'obj':
                self.result['widgets'][w_name]['inherits'] = 'obj'
                self.result['widgets'][w_name]['create'] = f'lv_{w_name}_create'

        # Initialize object types
        for o_name in self.object_types:
            self.result['objects'][o_name]['c_type'] = f'lv_{o_name}_t'
            self.result['objects'][o_name]['init'] = f'lv_{o_name}_init'

        # Process all functions and assign them
        for func in self.spec.get('functions', []):
            func_name = func.get('name', '')
            match = re.match(r"lv_([a-zA-Z0-9]+)_(.*)", func_name)
            if not match:
                continue

            target_name, action = match.groups()

            if target_name in self.widget_types:
                # All functions starting with lv_<widget>_* are methods
                self.result['widgets'][target_name]['methods'][func_name] = self.result['functions'][func_name]

                # Check if it's a property setter
                prop_name = None
                if action.startswith('set_'):
                    prop_name = action[4:]
                # Treat 'add_' and 'clear_' as property setters as well
                elif action.startswith(('add_', 'clear_')):
                    prop_name = action

                if prop_name:
                    prop_type = self._get_property_type(func)
                    self.result['widgets'][target_name]['properties'][prop_name] = {
                        "setter": func_name,
                        "type": prop_type
                    }

            elif target_name in self.object_types:
                # All functions starting with lv_<object>_* are methods
                self.result['objects'][target_name]['methods'][func_name] = self.result['functions'][func_name]

                # Check if it's a property setter
                prop_name = None
                if action.startswith('set_'):
                    prop_name = action[4:]
                # Treat 'add_' and 'clear_' as property setters as well
                elif action.startswith(('add_', 'clear_')):
                    prop_name = action

                if prop_name:
                    prop_type = self._get_property_type(func)
                    self.result['objects'][target_name]['properties'][prop_name] = {
                        "setter": func_name,
                        "type": prop_type
                    }

    def _finalize_and_sort(self):
        """Converts defaultdicts and sorts all keys for consistent output."""
        # Convert defaultdicts to regular dicts
        self.result['widgets'] = dict(self.result['widgets'])
        self.result['objects'] = dict(self.result['objects'])

        # Sort all top-level keys
        self.result = dict(sorted(self.result.items()))

        # Sort keys within each section for consistent ordering
        for key in ['constants', 'enums', 'functions', 'widgets', 'objects']:
            if key in self.result:
                self.result[key] = dict(sorted(self.result[key].items()))

        # Sort keys within each widget for consistent ordering
        for w_name, w_data in self.result.get('widgets', {}).items():
            if 'properties' in w_data:
                w_data['properties'] = dict(sorted(w_data['properties'].items()))
            if 'methods' in w_data:
                w_data['methods'] = dict(sorted(w_data['methods'].items()))
            self.result['widgets'][w_name] = dict(sorted(w_data.items()))

        # Sort keys within each object for consistent ordering
        for o_name, o_data in self.result.get('objects', {}).items():
            if 'properties' in o_data:
                o_data['properties'] = dict(sorted(o_data['properties'].items()))
            if 'methods' in o_data:
                o_data['methods'] = dict(sorted(o_data['methods'].items()))
            self.result['objects'][o_name] = dict(sorted(o_data.items()))

    def _notes(self):
        self.result['NOTES'] = 'DO NOT EDIT! This file is auto-generated by `generate_api_spec.py`, ie running `python3 generate_api_spec.py lv_def.json > api_spec.json`. lv_def.json is the ouput of lvgl `gen_json.py, see https://docs.lvgl.io/master/details/integration/bindings/api_json.html .'

    def parse(self):
        """Run all translation steps in order and return the final structure."""
        self._notes()
        self._discover_types()
        self._translate_primitives()
        self._structure_api()
        self._finalize_and_sort()

        return self.result

def main(filepath):
    """
    Loads the API spec file, runs the parser, and prints the result to stdout.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            api_spec = json.load(f)
    except FileNotFoundError:
        print(f"Error: File not found at '{filepath}'", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Could not decode JSON from '{filepath}': {e}", file=sys.stderr)
        sys.exit(1)

    parser = LVGLApiParser(api_spec)
    translated_spec = parser.parse()

    json.dump(translated_spec, sys.stdout, indent=2)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: python {sys.argv[0]} <path_to_api_spec.json>", file=sys.stderr)
        sys.exit(1)

    main(sys.argv[1])
