import json
import re
import sys
from collections import defaultdict
import argparse
import os
import shutil
import subprocess
import tempfile

"""
The JSON output generated by this file provides a comprehensive, high-level translation of the LVGL API. It transforms the flat C-style function list from the source specification into a hierarchical, object-oriented structure that is easier for tools to parse.

Key Sections:
*   **`widgets`**: Details the full widget hierarchy, defining each widget's parent, creation function, methods, and a list of high-level `properties` inferred from C setter functions (e.g., `lv_label_set_text` becomes a `text` property).
*   **`objects`**: Describes non-widget types like `style` and their associated properties and methods, mirroring the structure of `widgets`.
*   **`enums` / `constants`**: Provide exhaustive maps of all enumerated values and global constants. These are pre-resolved by this script.
*   **`functions`**: Contains a complete, flat reference of all raw C function signatures for tooling that requires full API access.
"""

class LVGLApiParser:
    """
    Parses the LVGL API specification JSON and translates it into a more
    structured, hierarchical format suitable for code generators or documentation.
    It also resolves complex C constant macros by generating and compiling a
    temporary C program.
    """

    def __init__(self, api_spec, args):
        """Initializes the parser with the raw API specification and command-line args."""
        self.spec = api_spec
        self.args = args
        self.result = {
            "constants": {},
            "enums": {},
            "functions": {},
            "widgets": defaultdict(lambda: {"properties": {}, "methods": {}}),
            "objects": defaultdict(lambda: {"properties": {}, "methods": {}}),
        }
        # Pre-populate with known types
        self.widget_types = {'obj'}
        self.object_types = {'style'}
        self.enum_type_names = set()

    def _get_type_str(self, type_info):
        """Recursively builds a string representation of a C type."""
        if not type_info:
            return "unknown"
        if type_info.get('json_type') == 'ret_type':
            return self._get_type_str(type_info.get('type'))
        if type_info.get('name') == 'void' and 'pointer' not in type_info.get('json_type', ''):
            return "void"

        suffix = ""
        current = type_info

        if current.get('json_type') == 'array':
            suffix += '*'
            if current.get('name', None) is None: current = current.get('type', {})

        while current.get('json_type') == 'pointer':
            suffix += '*'
            current = current.get('type', {})

        base_name = current.get('name') or current.get('type', {}).get('name') or "anonymous"
        if base_name == 'anonymous':
            print(">>> ", type_info, current.get('name'), current.get('type', {}).get('name'), current)
        return f"{base_name}{suffix}".strip()

    def _get_property_type(self, func_info):
        """Determines the C type of a property from its setter function."""
        args = func_info.get('args', [])
        if len(args) < 2:
            return 'unknown'
        # The second argument is usually the value being set.
        val_arg = args[1]
        return self._get_type_str(val_arg.get('type'))

    def _discover_types(self):
        """First pass to identify all enum, widget, and object types."""
        for enum in self.spec.get('enums', []):
            if enum.get('name'):
                self.enum_type_names.add(enum['name'])

        for func in self.spec.get('functions', []):
            name = func.get('name', '')
            if name.endswith('_create'):
                match = re.match(r"lv_(\w+)_create", name)
                if match:
                    self.widget_types.add(match.group(1))
            elif name.endswith('_init'):
                match = re.match(r"lv_(\w+)_init", name)
                if match and match.group(1):
                    if match.group(1) not in ['mem']:
                        self.object_types.add(match.group(1))

    def _translate_primitives(self):
        """Translate enums, constants, and raw function signatures."""
        for enum in self.spec.get('enums', []):
            members = {member['name']: member['value'] for member in enum.get('members', [])}
            if enum.get('name'):
                self.result['enums'][enum['name']] = members
            else:
                print("!!", enum, members)
                self.result['constants'].update(members)

        for macro in self.spec.get('macros', []):
            if macro.get('params') is None and macro.get('initializer'):
                self.result['constants'][macro['name']] = macro['initializer']

        for func in self.spec.get('functions', []):
            func_name = func.get('name', '')
            if not func_name: continue
            ret_type_str = self._get_type_str(func.get('type'))
            args_list = []
            if func.get('args'):
                is_void_arg = len(func['args']) == 1 and self._get_type_str(func['args'][0].get('type')) == 'void'
                if not is_void_arg:
                    args_list = [self._get_type_str(arg.get('type')) for arg in func['args']]
            self.result['functions'][func_name] = {"return_type": ret_type_str, "args": args_list}

    def _is_complex_constant(self, value_str):
        """Robust heuristic to detect if a constant's value is a C expression."""
        if not isinstance(value_str, str): return False
        processed_val = re.sub(r'/\*.*?\*/', '', value_str).strip()
        if not processed_val: return False
        if processed_val.startswith('"') and processed_val.endswith('"'): return False
        if ';' in processed_val: return False
        try:
            int(processed_val, 0)
            return False
        except (ValueError, TypeError):
            pass
        return True

    def _evaluate_complex_constants(self, constants):
        """Generates, compiles, and runs a C program to resolve complex constant macros."""

        excludes = [
"LV_GLOBAL_DEFAULT", "LV_DPX_CALC", "LV_DPX", "LV_DRAW_BUF_STRIDE", "LV_DRAW_BUF_SIZE", "LV_MASK_ID_INV", "DL_CLEAR", "DL_CLEAR_RGB", "DL_COLOR_RGB", "DL_POINT_SIZE", "DL_END", "DL_BEGIN", "DL_DISPLAY", "EVE_NEVER", "EVE_LESS", "EVE_LEQUAL", "EVE_GREATER", "EVE_GEQUAL", "EVE_EQUAL", "EVE_NOTEQUAL", "EVE_ALWAYS", "EVE_ARGB1555", "EVE_L1", "EVE_L4", "EVE_L8", "EVE_RGB332", "EVE_ARGB2", "EVE_ARGB4", "EVE_RGB565", "EVE_PALETTED", "EVE_TEXT8X8", "EVE_TEXTVGA", "EVE_BARGRAPH", "EVE_NEAREST", "EVE_BILINEAR", "EVE_BORDER", "EVE_REPEAT", "EVE_KEEP", "EVE_REPLACE", "EVE_INCR", "EVE_DECR", "EVE_INVERT", "EVE_DLSWAP_DONE", "EVE_DLSWAP_LINE", "EVE_DLSWAP_FRAME", "EVE_ZERO", "EVE_ONE", "EVE_SRC_ALPHA", "EVE_DST_ALPHA", "EVE_ONE_MINUS_SRC_ALPHA", "EVE_ONE_MINUS_DST_ALPHA", "EVE_BITMAPS", "EVE_POINTS", "EVE_LINES", "EVE_LINE_STRIP", "EVE_EDGE_STRIP_R", "EVE_EDGE_STRIP_L", "EVE_EDGE_STRIP_A", "EVE_EDGE_STRIP_B", "EVE_RECTS", "EVE_OPT_CENTER", "EVE_NUMCHAR_PERFONT", "EVE_FONT_TABLE_SIZE", "EVE_FONT_TABLE_POINTER", "EVE_LINEAR_SAMPLES", "EVE_ULAW_SAMPLES", "EVE_ADPCM_SAMPLES", "EVE_PIPS", "ALPHA_FUNC", "BEGIN", "BITMAP_HANDLE", "BITMAP_LAYOUT", "BITMAP_SIZE", "BITMAP_TRANSFORM_A", "BITMAP_TRANSFORM_B", "BITMAP_TRANSFORM_C", "BITMAP_TRANSFORM_D", "BITMAP_TRANSFORM_E", "BITMAP_TRANSFORM_F", "BLEND_FUNC", "CALL", "CELL", "CLEAR", "CLEAR_COLOR_A", "CLEAR_COLOR_RGB", "CLEAR_STENCIL", "CLEAR_TAG", "COLOR_A", "COLOR_MASK", "COLOR_RGB", "END", "JUMP", "LINE_WIDTH", "MACRO", "POINT_SIZE", "RESTORE_CONTEXT", "RETURN", "SAVE_CONTEXT", "STENCIL_FUNC", "STENCIL_MASK", "STENCIL_OP", "TAG", "TAG_MASK", "VERTEX2F", "VERTEX2II", "EVE_RAM_G", "EVE_ROM_CHIPID", "EVE_ROM_FONT", "EVE_ROM_FONT_ADDR", "EVE_RAM_DL", "EVE_RAM_REG", "EVE_RAM_CMD", "EVE_RAM_G_SIZE", "EVE_CMDFIFO_SIZE", "EVE_RAM_DL_SIZE", "EVE_ADC_DIFFERENTIAL", "EVE_ADC_SINGLE_ENDED", "EVE_INT_G8", "EVE_INT_L8C", "EVE_INT_VGA", "EVE_OPT_MEDIAFIFO", "EVE_OPT_FULLSCREEN", "EVE_OPT_NOTEAR", "EVE_OPT_SOUND", "EVE_PALETTED565", "EVE_PALETTED4444", "EVE_PALETTED8", "EVE_L2", "REG_ANA_COMP", "REG_BIST_EN", "REG_CLOCK", "REG_CMDB_SPACE", "REG_CMDB_WRITE", "REG_CMD_DL", "REG_CMD_READ", "REG_CMD_WRITE", "REG_CPURESET", "REG_CSPREAD", "REG_CTOUCH_EXTENDED", "REG_CTOUCH_TOUCH0_XY", "REG_CTOUCH_TOUCH4_X", "REG_CTOUCH_TOUCH4_Y", "REG_CTOUCH_TOUCH1_XY", "REG_CTOUCH_TOUCH2_XY", "REG_CTOUCH_TOUCH3_XY", "REG_TOUCH_CONFIG", "REG_DATESTAMP", "REG_DITHER", "REG_DLSWAP", "REG_FRAMES", "REG_FREQUENCY", "REG_GPIO", "REG_GPIOX", "REG_GPIOX_DIR", "REG_GPIO_DIR", "REG_HCYCLE", "REG_HOFFSET", "REG_HSIZE", "REG_HSYNC0", "REG_HSYNC1", "REG_ID", "REG_INT_EN", "REG_INT_FLAGS", "REG_INT_MASK", "REG_MACRO_0", "REG_MACRO_1", "REG_MEDIAFIFO_READ", "REG_MEDIAFIFO_WRITE", "REG_OUTBITS", "REG_PCLK", "REG_PCLK_POL", "REG_PLAY", "REG_PLAYBACK_FORMAT", "REG_PLAYBACK_FREQ", "REG_PLAYBACK_LENGTH", "REG_PLAYBACK_LOOP", "REG_PLAYBACK_PLAY", "REG_PLAYBACK_READPTR", "REG_PLAYBACK_START", "REG_PWM_DUTY", "REG_PWM_HZ", "REG_RENDERMODE", "REG_ROTATE", "REG_SNAPFORMAT", "REG_SNAPSHOT", "REG_SNAPY", "REG_SOUND", "REG_SPI_WIDTH", "REG_SWIZZLE", "REG_TAG", "REG_TAG_X", "REG_TAG_Y", "REG_TAP_CRC", "REG_TAP_MASK", "REG_TOUCH_ADC_MODE", "REG_TOUCH_CHARGE", "REG_TOUCH_DIRECT_XY", "REG_TOUCH_DIRECT_Z1Z2", "REG_TOUCH_MODE", "REG_TOUCH_OVERSAMPLE", "REG_TOUCH_RAW_XY", "REG_TOUCH_RZ", "REG_TOUCH_RZTHRESH", "REG_TOUCH_SCREEN_XY", "REG_TOUCH_SETTLE", "REG_TOUCH_TAG", "REG_TOUCH_TAG1", "REG_TOUCH_TAG1_XY", "REG_TOUCH_TAG2", "REG_TOUCH_TAG2_XY", "REG_TOUCH_TAG3", "REG_TOUCH_TAG3_XY", "REG_TOUCH_TAG4", "REG_TOUCH_TAG4_XY", "REG_TOUCH_TAG_XY", "REG_TOUCH_TRANSFORM_A", "REG_TOUCH_TRANSFORM_B", "REG_TOUCH_TRANSFORM_C", "REG_TOUCH_TRANSFORM_D", "REG_TOUCH_TRANSFORM_E", "REG_TOUCH_TRANSFORM_F", "REG_TRACKER", "REG_TRACKER_1", "REG_TRACKER_2", "REG_TRACKER_3", "REG_TRACKER_4", "REG_TRIM", "REG_VCYCLE", "REG_VOFFSET", "REG_VOL_PB", "REG_VOL_SOUND", "REG_VSIZE", "REG_VSYNC0", "REG_VSYNC1", "BITMAP_LAYOUT_H", "BITMAP_SIZE_H", "BITMAP_SOURCE", "PALETTE_SOURCE", "SCISSOR_SIZE", "SCISSOR_XY", "VERTEX_FORMAT", "VERTEX_TRANSLATE_X", "VERTEX_TRANSLATE_Y", "LV_GRID_FR", "LV_DRAW_BUF_DEFINE_STATIC", "LV_LL_READ", "LV_LL_READ_BACK", "LV_FS_IS_VALID_LETTER", "_PARA", "LV_ANIM_SET_EASE_IN_SINE", "LV_ANIM_SET_EASE_OUT_SINE", "LV_ANIM_SET_EASE_IN_OUT_SINE", "LV_ANIM_SET_EASE_IN_QUAD", "LV_ANIM_SET_EASE_OUT_QUAD", "LV_ANIM_SET_EASE_IN_OUT_QUAD", "LV_ANIM_SET_EASE_IN_CUBIC", "LV_ANIM_SET_EASE_OUT_CUBIC", "LV_ANIM_SET_EASE_IN_OUT_CUBIC", "LV_ANIM_SET_EASE_IN_QUART", "LV_ANIM_SET_EASE_OUT_QUART", "LV_ANIM_SET_EASE_IN_OUT_QUART", "LV_ANIM_SET_EASE_IN_QUINT", "LV_ANIM_SET_EASE_OUT_QUINT", "LV_ANIM_SET_EASE_IN_OUT_QUINT", "LV_ANIM_SET_EASE_IN_EXPO", "LV_ANIM_SET_EASE_OUT_EXPO", "LV_ANIM_SET_EASE_IN_OUT_EXPO", "LV_ANIM_SET_EASE_IN_CIRC", "LV_ANIM_SET_EASE_OUT_CIRC", "LV_ANIM_SET_EASE_IN_OUT_CIRC", "LV_ANIM_SET_EASE_IN_BACK", "LV_ANIM_SET_EASE_OUT_BACK", "LV_ANIM_SET_EASE_IN_OUT_BACK", "LV_COORD_TYPE", "LV_COORD_PLAIN", "LV_COORD_IS_PX", "LV_COORD_IS_SPEC", "LV_COORD_SET_SPEC", "LV_PCT", "LV_COORD_IS_PCT", "LV_COORD_GET_PCT", "LV_COLOR_FORMAT_GET_SIZE", "LV_COLOR_FORMAT_IS_ALPHA_ONLY", "LV_COLOR_FORMAT_IS_INDEXED", "LV_COLOR_FORMAT_IS_YUV", "LV_COLOR_INDEXED_PALETTE_SIZE", "LV_COLOR_MAKE", "LV_OPA_MIX2", "LV_OPA_MIX3", "LV_LOG_TRACE", "LV_LOG_INFO", "LV_LOG_WARN", "LV_LOG_ERROR", "LV_LOG_USER", "LV_LOG", "LV_BEZIER_VAL_FLOAT", "LV_ALIGN_UP", "LV_ROUND_UP", "LV_MIN", "LV_MIN3", "LV_MIN4", "LV_MAX", "LV_MAX3", "LV_MAX4", "LV_CLAMP", "LV_ABS", "LV_UDIV255", "LV_IS_SIGNED", "LV_UMAX_OF", "LV_SMAX_OF", "LV_MAX_OF", "LV_PROFILER_BEGIN_TAG", "LV_PROFILER_END_TAG", "LV_STYLE_CONST_INIT", "LV_STYLE_CONST_WIDTH", "LV_STYLE_CONST_MIN_WIDTH", "LV_STYLE_CONST_MAX_WIDTH", "LV_STYLE_CONST_HEIGHT", "LV_STYLE_CONST_MIN_HEIGHT", "LV_STYLE_CONST_MAX_HEIGHT", "LV_STYLE_CONST_LENGTH", "LV_STYLE_CONST_X", "LV_STYLE_CONST_Y", "LV_STYLE_CONST_ALIGN", "LV_STYLE_CONST_TRANSFORM_WIDTH", "LV_STYLE_CONST_TRANSFORM_HEIGHT", "LV_STYLE_CONST_TRANSLATE_X", "LV_STYLE_CONST_TRANSLATE_Y", "LV_STYLE_CONST_TRANSLATE_RADIAL", "LV_STYLE_CONST_TRANSFORM_SCALE_X", "LV_STYLE_CONST_TRANSFORM_SCALE_Y", "LV_STYLE_CONST_TRANSFORM_ROTATION", "LV_STYLE_CONST_TRANSFORM_PIVOT_X", "LV_STYLE_CONST_TRANSFORM_PIVOT_Y", "LV_STYLE_CONST_TRANSFORM_SKEW_X", "LV_STYLE_CONST_TRANSFORM_SKEW_Y", "LV_STYLE_CONST_PAD_TOP", "LV_STYLE_CONST_PAD_BOTTOM", "LV_STYLE_CONST_PAD_LEFT", "LV_STYLE_CONST_PAD_RIGHT", "LV_STYLE_CONST_PAD_ROW", "LV_STYLE_CONST_PAD_COLUMN", "LV_STYLE_CONST_PAD_RADIAL", "LV_STYLE_CONST_MARGIN_TOP", "LV_STYLE_CONST_MARGIN_BOTTOM", "LV_STYLE_CONST_MARGIN_LEFT", "LV_STYLE_CONST_MARGIN_RIGHT", "LV_STYLE_CONST_BG_COLOR", "LV_STYLE_CONST_BG_OPA", "LV_STYLE_CONST_BG_GRAD_COLOR", "LV_STYLE_CONST_BG_GRAD_DIR", "LV_STYLE_CONST_BG_MAIN_STOP", "LV_STYLE_CONST_BG_GRAD_STOP", "LV_STYLE_CONST_BG_MAIN_OPA", "LV_STYLE_CONST_BG_GRAD_OPA", "LV_STYLE_CONST_BG_GRAD", "LV_STYLE_CONST_BG_IMAGE_SRC", "LV_STYLE_CONST_BG_IMAGE_OPA", "LV_STYLE_CONST_BG_IMAGE_RECOLOR", "LV_STYLE_CONST_BG_IMAGE_RECOLOR_OPA", "LV_STYLE_CONST_BG_IMAGE_TILED", "LV_STYLE_CONST_BORDER_COLOR", "LV_STYLE_CONST_BORDER_OPA", "LV_STYLE_CONST_BORDER_WIDTH", "LV_STYLE_CONST_BORDER_SIDE", "LV_STYLE_CONST_BORDER_POST", "LV_STYLE_CONST_OUTLINE_WIDTH", "LV_STYLE_CONST_OUTLINE_COLOR", "LV_STYLE_CONST_OUTLINE_OPA", "LV_STYLE_CONST_OUTLINE_PAD", "LV_STYLE_CONST_SHADOW_WIDTH", "LV_STYLE_CONST_SHADOW_OFFSET_X", "LV_STYLE_CONST_SHADOW_OFFSET_Y", "LV_STYLE_CONST_SHADOW_SPREAD", "LV_STYLE_CONST_SHADOW_COLOR", "LV_STYLE_CONST_SHADOW_OPA", "LV_STYLE_CONST_IMAGE_OPA", "LV_STYLE_CONST_IMAGE_RECOLOR", "LV_STYLE_CONST_IMAGE_RECOLOR_OPA", "LV_STYLE_CONST_LINE_WIDTH", "LV_STYLE_CONST_LINE_DASH_WIDTH", "LV_STYLE_CONST_LINE_DASH_GAP", "LV_STYLE_CONST_LINE_ROUNDED", "LV_STYLE_CONST_LINE_COLOR", "LV_STYLE_CONST_LINE_OPA", "LV_STYLE_CONST_ARC_WIDTH", "LV_STYLE_CONST_ARC_ROUNDED", "LV_STYLE_CONST_ARC_COLOR", "LV_STYLE_CONST_ARC_OPA", "LV_STYLE_CONST_ARC_IMAGE_SRC", "LV_STYLE_CONST_TEXT_COLOR", "LV_STYLE_CONST_TEXT_OPA", "LV_STYLE_CONST_TEXT_FONT", "LV_STYLE_CONST_TEXT_LETTER_SPACE", "LV_STYLE_CONST_TEXT_LINE_SPACE", "LV_STYLE_CONST_TEXT_DECOR", "LV_STYLE_CONST_TEXT_ALIGN", "LV_STYLE_CONST_TEXT_OUTLINE_STROKE_COLOR", "LV_STYLE_CONST_TEXT_OUTLINE_STROKE_WIDTH", "LV_STYLE_CONST_TEXT_OUTLINE_STROKE_OPA", "LV_STYLE_CONST_RADIUS", "LV_STYLE_CONST_RADIAL_OFFSET", "LV_STYLE_CONST_CLIP_CORNER", "LV_STYLE_CONST_OPA", "LV_STYLE_CONST_OPA_LAYERED", "LV_STYLE_CONST_COLOR_FILTER_DSC", "LV_STYLE_CONST_COLOR_FILTER_OPA", "LV_STYLE_CONST_RECOLOR", "LV_STYLE_CONST_RECOLOR_OPA", "LV_STYLE_CONST_ANIM", "LV_STYLE_CONST_ANIM_DURATION", "LV_STYLE_CONST_TRANSITION", "LV_STYLE_CONST_BLEND_MODE", "LV_STYLE_CONST_LAYOUT", "LV_STYLE_CONST_BASE_DIR", "LV_STYLE_CONST_BITMAP_MASK_SRC", "LV_STYLE_CONST_ROTARY_SENSITIVITY", "LV_TREE_NODE", "LV_CANVAS_BUF_SIZE", "LV_IMAGE_DECLARE",
"LV_DRAW_BUF_DEFINE_STATIC", "ac", "lv_draw_buf_invalidate_cache_user", "lv_draw_buf_flush_cache_user", "lv_draw_buf_destroy_user", "lv_event_mark_deleted", "lv_area_is_equal", "lv_area_is_in", "lv_area_intersect", "lv_area_is_point_on", "lv_area_join", "lv_image_buf_get_transformed_area", "LV_LL_READ", "LV_LL_READ_BACK", "lv_obj_scroll_by_raw", "lv_obj_get_ext_draw_size", "lv_indev_scroll_handler", "lv_obj_find_by_id", "lv_inv_area",
"lv_obj_del", "lv_obj_del_async", "lv_obj_clear_flag", "lv_obj_clear_state", "lv_indev_set_disp", "lv_indev_get_act", "lv_scr_act", "lv_disp_remove", "lv_disp_set_default", "lv_disp_get_default", "lv_disp_get_next", "lv_disp_set_rotation", "lv_disp_get_hor_res", "lv_disp_get_ver_res", "lv_disp_get_physical_hor_res", "lv_disp_get_physical_ver_res", "lv_disp_get_offset_x", "lv_disp_get_offset_y", "lv_disp_get_rotation", "lv_disp_get_dpi", "lv_disp_get_antialiasing", "lv_disp_flush_ready", "lv_disp_flush_is_last", "lv_disp_get_scr_act", "lv_disp_get_scr_prev", "lv_disp_load_scr", "lv_scr_load", "lv_scr_load_anim", "lv_disp_get_layer_top", "lv_disp_get_layer_sys", "lv_disp_send_event", "lv_disp_set_theme", "lv_disp_get_theme", "lv_disp_get_inactive_time", "lv_disp_trig_activity", "lv_disp_enable_invalidation", "lv_disp_is_invalidation_enabled", "lv_disp_refr_timer", "lv_disp_get_refr_timer", "lv_timer_del", "lv_anim_del", "lv_anim_del_all", "lv_anim_set_ready_cb", "lv_group_del", "lv_txt_get_size", "lv_txt_get_width", "lv_img_create", "lv_img_set_src", "lv_img_set_offset_x", "lv_img_set_offset_y", "lv_img_set_angle", "lv_img_set_pivot", "lv_img_set_zoom", "lv_img_set_antialias", "lv_img_get_src", "lv_img_get_offset_x", "lv_img_get_offset_y", "lv_img_get_angle", "lv_img_get_pivot", "lv_img_get_zoom", "lv_img_get_antialias", "lv_imgbtn_create", "lv_imgbtn_set_src", "lv_imgbtn_set_state", "lv_imgbtn_get_src_left", "lv_imgbtn_get_src_middle", "lv_imgbtn_get_src_right", "lv_list_set_btn_text", "lv_list_get_btn_text", "lv_list_add_btn", "lv_btn_create", "lv_btnmatrix_create", "lv_btnmatrix_set_map", "lv_btnmatrix_set_ctrl_map", "lv_btnmatrix_set_selected_btn", "lv_btnmatrix_set_btn_ctrl", "lv_btnmatrix_clear_btn_ctrl", "lv_btnmatrix_set_btn_ctrl_all", "lv_btnmatrix_clear_btn_ctrl_all", "lv_btnmatrix_set_btn_width", "lv_btnmatrix_set_one_checked", "lv_btnmatrix_get_map", "lv_btnmatrix_get_selected_btn", "lv_btnmatrix_get_btn_text", "lv_btnmatrix_has_button_ctrl", "lv_btnmatrix_get_one_checked", "lv_tabview_get_tab_btns", "lv_tabview_get_tab_act", "lv_tabview_set_act", "lv_tileview_get_tile_act", "lv_obj_set_tile_id", "lv_obj_set_tile", "lv_roller_set_visible_row_cnt", "lv_roller_get_option_cnt", "lv_table_set_col_cnt", "lv_table_set_row_cnt", "lv_table_get_col_cnt", "lv_table_get_row_cnt", "lv_table_set_col_width", "lv_table_get_col_width", "lv_dropdown_get_option_cnt", "lv_obj_get_child_cnt", "lv_obj_get_disp", "lv_obj_delete_anim_ready_cb", "lv_obj_get_style_anim_time", "lv_obj_get_style_img_opa", "lv_obj_get_style_img_recolor", "lv_obj_get_style_img_recolor_filtered", "lv_obj_get_style_img_recolor_opa", "lv_obj_get_style_shadow_ofs_x", "lv_obj_get_style_shadow_ofs_y", "lv_obj_get_style_transform_angle", "lv_obj_get_style_bg_img_src", "lv_obj_get_style_bg_img_recolor", "lv_obj_get_style_bg_img_recolor_opa", "lv_obj_set_style_anim_time", "lv_obj_set_style_img_opa", "lv_obj_set_style_img_recolor", "lv_obj_set_style_img_recolor_opa", "lv_obj_set_style_shadow_ofs_x", "lv_obj_set_style_shadow_ofs_y", "lv_obj_set_style_transform_zoom", "lv_obj_set_style_transform_angle", "lv_obj_set_style_bg_img_src", "lv_obj_set_style_bg_img_recolor", "lv_obj_set_style_bg_img_recolor_opa", "lv_style_set_anim_time", "lv_style_set_img_opa", "lv_style_set_img_recolor", "lv_style_set_img_recolor_opa", "lv_style_set_shadow_ofs_x", "lv_style_set_shadow_ofs_y", "lv_style_set_transform_angle", "lv_style_set_transform_zoom", "lv_style_set_bg_img_src", "lv_style_set_bg_img_recolor", "lv_style_set_bg_img_recolor_opa", "lv_keyboard_get_selected_btn", "lv_keyboard_get_btn_text", "lv_image_decoder_built_in_open", "lv_image_decoder_built_in_close", "lv_image_set_align", "lv_image_get_align", "lv_button_bind_checked", "LV_DRAW_BUF_DEFINE", "LV_DRAW_BUF_DEFINE", "_lv_utils_bsearch", "lv_draw_buf_align_user", "lv_draw_buf_create_user", "lv_draw_buf_width_to_stride_user", "lv_draw_buf_dup_user", "_lv_event_code_t", "_lv_event_mark_deleted", "lv_obj_add_event", "_lv_area_is_equal", "_lv_area_is_in", "_lv_area_intersect", "_lv_area_is_point_on", "_lv_area_join", "_lv_image_buf_get_transformed_area", "_lv_ll_init", "_lv_ll_ins_head", "_lv_ll_ins_prev", "_lv_ll_ins_tail", "_lv_ll_get_head", "_lv_ll_get_tail", "_lv_ll_get_next", "_lv_ll_get_prev", "_lv_ll_get_len", "_lv_ll_move_before", "_lv_ll_is_empty", "_lv_ll_clear", "_lv_ll_remove", "_lv_ll_chg_list", "_LV_LL_READ", "_LV_LL_READ_BACK", "_lv_obj_scroll_by_raw", "_lv_obj_get_ext_draw_size", "_lv_indev_scroll_handler", "lv_obj_get_child_by_id", "lv_obj_update_flag", "_lv_inv_area", "lv_chart_set_all_value", "lv_calendar_set_showed_date", "lv_chart_set_range", "lv_chart_set_value_by_id", "lv_chart_get_x_array", "lv_chart_get_y_array", "lv_chart_set_ext_x_array", "lv_chart_set_ext_y_array", "lv_anim_set_time", "lv_anim_set_playback_time", "lv_anim_set_playback_delay", "lv_anim_set_playback_duration", "lv_gradient_init_stops", "lv_gradient_stop_t", "lv_spangroup_new_span", "lv_spangroup_refr_mode", "lv_slider_set_left_value", "lv_calendar_header_arrow_create", "lv_calendar_header_dropdown_create",
"lv_display_get_default",
"lv_display_get_horizontal_resolution",
"lv_display_get_default",
"lv_display_get_vertical_resolution",
"_lv_display_refr_timer", "_lv_disp_refr_timer", "_lv_disp_get_refr_timer", "LV_STYLE_CONST_PROPS_END"
        ]

        complex_consts = {k: v for k, v in constants.items() if (not k in excludes) and self._is_complex_constant(v)}
        if not complex_consts:
            print("No complex constants found to evaluate.", file=sys.stderr)
            return

        print(f"Found {len(complex_consts)} complex constants to evaluate using C compiler.", file=sys.stderr)
        temp_dir = tempfile.mkdtemp()
        c_file_path = os.path.join(temp_dir, "const_resolver.c")
        exe_file_path = os.path.join(temp_dir, "const_resolver")

        c_source_lines = [
            '#include <stdio.h>',
            '#include <stdlib.h>',
            '#include "cJSON.h"',
        ]

        # Handle lv_conf.h inclusion
        include_paths = ["-I.", "-I./cJSON", "-I./lvgl"]
        if self.args.lvgl_conf:
            conf_path = os.path.abspath(self.args.lvgl_conf)
            conf_dir = os.path.dirname(conf_path)
            conf_name = os.path.basename(conf_path)
            include_paths.append(f"-I{conf_dir}")
            c_source_lines.append(f'#include "{conf_name}"')

        c_source_lines.append('#include "lvgl.h"')
        c_source_lines.extend([
            'int main() {',
            '    cJSON *root = cJSON_CreateObject();',
            '    if (!root) return 1;'
        ])

        for name in complex_consts:
            c_source_lines.append(f'    cJSON_AddItemToObject(root, "{name}", cJSON_CreateNumber({name}));')

        user_consts = [
                    ['LV_GRID_FR1', 'LV_GRID_FR(1)'],
                    ['LV_GRID_FR2', 'LV_GRID_FR(2)'],
                    ['LV_GRID_FR3', 'LV_GRID_FR(3)'],
                    ['LV_GRID_FR4', 'LV_GRID_FR(4)'],
                    ['LV_GRID_FR5', 'LV_GRID_FR(5)'],
                    ['LV_GRID_FR6', 'LV_GRID_FR(6)'],
                    ['LV_GRID_FR7', 'LV_GRID_FR(7)'],
                    ['LV_GRID_FR8', 'LV_GRID_FR(8)'],
                    ['LV_GRID_FR9', 'LV_GRID_FR(9)'],
                    ['LV_GRID_FR10', 'LV_GRID_FR(10)']
                ]
        for name, exp in user_consts:
            c_source_lines.append(f'    cJSON_AddItemToObject(root, "{name}", cJSON_CreateNumber({exp}));')

        c_source_lines.extend([
            #'    char* out = cJSON_PrintUnformatted(root);',
            '    char* out = cJSON_Print(root);',
            '    if (out) { printf("%s", out); free(out); }',
            '    cJSON_Delete(root);',
            '    return 0;',
            '}'
        ])

        try:
            with open(c_file_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(c_source_lines))

            cjson_c_path = os.path.join("cJSON", "cJSON.c")
            lv_assert_c_path = os.path.join("viewer", "lvgl_assert_handler.c")
            compile_command = ["gcc", "-o", exe_file_path, c_file_path, cjson_c_path, lv_assert_c_path] + include_paths + ["-lm", "-L./lvgl/build/lib", "-llvgl"]

            print("Compiling temporary C program to resolve constants...", file=sys.stderr)
            print(', '.join(compile_command), file=sys.stderr)
            subprocess.run(compile_command, check=True, capture_output=True, text=True)

            print("Executing program to get constant values...", file=sys.stderr)
            run_result = subprocess.run([exe_file_path], check=True, capture_output=True, text=True)
            resolved_json = json.loads(run_result.stdout)

            updated_count = 0
            users_const_keys = [k for k, _ in user_consts]
            for name, value in resolved_json.items():
                if name in constants or name in users_const_keys:
                    constants[name] = str(value)
                    # print(f"{name} => {value}", file=sys.stderr)
                    updated_count += 1
            print(f"Successfully evaluated and updated {updated_count} constants.", file=sys.stderr)

        except FileNotFoundError:
            print("\nWarning: `gcc` not found. Cannot evaluate complex constants.", file=sys.stderr)
            print("         Proceeding with string representations.", file=sys.stderr)
        except subprocess.CalledProcessError as e:
            print("\nError: Compilation/Execution of constant resolver failed.", file=sys.stderr)
            print(e.stderr, file=sys.stderr)
        except json.JSONDecodeError:
            print("Error: Could not parse JSON output from constant resolver.", file=sys.stderr)
        finally:
            shutil.rmtree(temp_dir)

    def _structure_api(self):
        """Organize functions into widget/object properties and methods."""
        self.result['widgets']['obj']['inherits'] = None
        for w_name in self.widget_types:
            if w_name != 'obj':
                self.result['widgets'][w_name]['inherits'] = 'obj'
                self.result['widgets'][w_name]['create'] = f'lv_{w_name}_create'

        for o_name in self.object_types:
            self.result['objects'][o_name]['c_type'] = f'lv_{o_name}_t'
            self.result['objects'][o_name]['init'] = f'lv_{o_name}_init'

        for func in self.spec.get('functions', []):
            func_name = func.get('name', '')
            match = re.match(r"lv_([a-zA-Z0-9]+)_(.*)", func_name)
            if not match: continue

            target_name, action = match.groups()
            container = None
            if target_name in self.widget_types:
                container = self.result['widgets'][target_name]
            elif target_name in self.object_types:
                container = self.result['objects'][target_name]

            if container:
                container['methods'][func_name] = self.result['functions'][func_name]
                prop_name = action[4:] if action.startswith('set_') else (action if action.startswith(('add_', 'clear_')) else None)

                if prop_name:
                    prop_type = self._get_property_type(func)
                    property_entry = {"setter": func_name, "type": prop_type}
                    if prop_type in self.enum_type_names:
                        property_entry["expected_enum_type"] = prop_type
                    container['properties'][prop_name] = property_entry
                    if prop_name.startswith('style_'):
                         container['properties'][prop_name[6:]] = dict(property_entry)

    def _finalize_and_sort(self):
        """Converts defaultdicts and sorts all keys for consistent output."""
        self.result['widgets'] = dict(sorted(self.result['widgets'].items()))
        self.result['objects'] = dict(sorted(self.result['objects'].items()))
        for key in ['constants', 'enums', 'functions']:
            self.result[key] = dict(sorted(self.result[key].items()))
        for data in list(self.result['widgets'].values()) + list(self.result['objects'].values()):
            if 'properties' in data:
                data['properties'] = dict(sorted(data['properties'].items()))
            if 'methods' in data:
                data['methods'] = dict(sorted(data['methods'].items()))

    def _notes(self):
        self.result['NOTES'] = 'DO NOT EDIT! This file is auto-generated by `generate_api_spec.py`.'

    def parse(self):
        """Run all translation steps in order and return the final structure."""
        self._notes()
        self._discover_types()
        self._translate_primitives()
        if not self.args.no_eval_constants:
            self._evaluate_complex_constants(self.result['constants'])
        self._structure_api()
        self._finalize_and_sort()
        return self.result

def main():
    """Loads the raw lv_def.json, runs the parser, and prints the result to stdout."""
    parser = argparse.ArgumentParser(description="Generate a structured api_spec.json from an lv_def.json file.")
    parser.add_argument("lv_def_path", help="Path to the raw lv_def.json API spec file.")
    parser.add_argument("--no-eval-constants", action="store_true", help="Disable evaluation of complex C constants.")
    parser.add_argument("--lvgl-conf", help="Path to a custom lv_conf.h file to use for constant evaluation.")
    args = parser.parse_args()

    try:
        with open(args.lv_def_path, 'r', encoding='utf-8') as f:
            api_spec = json.load(f)
    except FileNotFoundError:
        print(f"Error: File not found at '{args.lv_def_path}'", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Could not decode JSON from '{args.lv_def_path}': {e}", file=sys.stderr)
        sys.exit(1)

    parser = LVGLApiParser(api_spec, args)
    translated_spec = parser.parse()
    json.dump(translated_spec, sys.stdout, indent=2)

if __name__ == '__main__':
    main()
