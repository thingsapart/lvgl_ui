#include "lvgl.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Global variable for the style defined in JSON
lv_style_t* style_0; // For @container

// Global variable for the tileview from "id": "@main_tileview"
lv_obj_t* main_tileview;

// Assuming ui_registry is a global or accessible variable
// extern Registry* ui_registry;

void setup_ui(lv_obj_t* parent) {
    // Style creation for "@container"
    style_0 = (lv_style_t*)malloc(sizeof(lv_style_t));
    if (style_0 != NULL) {
        memset(style_0, 0, sizeof(lv_style_t));
        lv_style_init(style_0);
    } else {
        fprintf(stderr, "Error: Failed to allocate memory for style_0 (lv_style_t)\n");
    }
    // Assuming the generator registers the style variable if needed, e.g.:
    // registry_add_generated_var(ui_registry, "container", "style_0"); // if @ means use this C var
    // Or, if @ means lookup from registry which was populated by a style definition elsewhere:
    // style_0 = (lv_style_t*)registry_get_pointer(ui_registry, "container"); // More likely for an @id reference

    // For this test, we assume style_0 is the C variable for @container after its definition.
    // The generator should make style_0 point to the style if it's defined in the same file.
    // If "@container" was an external style, style_0 would need to be assigned appropriately.
    // Given the JSON, @container is defined here, so style_0 is its C variable.
    registry_add_generated_var(ui_registry, "container", "style_0"); // If id maps to C var name directly for styles.
                                                                // Or registry_add_pointer if styles are treated as pointers.
                                                                // For this test, style_0 is the direct C var.

    // Component @jog_view is defined, code generation is deferred until 'use-view'.

    // Tileview creation and property processing
    // "id": "@main_tileview" should lead to C variable main_tileview
    main_tileview = lv_tileview_create(parent);
    registry_add_generated_var(ui_registry, "main_tileview", "main_tileview"); // Register C var for ID
    // registry_add_pointer(ui_registry, main_tileview, "main_tileview", "tileview"); // Also register the instance pointer

    // "add_style": [ "@container", 0 ]
    lv_obj_add_style(main_tileview, style_0, 0);
    // "size": [ "100%", "100%" ]
    lv_obj_set_size(main_tileview, lv_pct(100), lv_pct(100));
    // "pad_row": 0
    lv_obj_set_style_pad_row(main_tileview, 0, 0);
    // "pad_column": 0
    lv_obj_set_style_pad_column(main_tileview, 0, 0);

    // "//": "First WITH (tile1)"
    /* First WITH (tile1) */
    // 'with.obj' is a call: lv_tileview_add_tile(main_tileview, 0, 0, LV_DIR_RIGHT)
    // process_single_with_block creates obj_0 for the result of the call.
    // The actual C function lv_tileview_add_tile needs main_tileview as its first arg.
    lv_obj_t* tile_obj_0 = lv_tileview_add_tile(main_tileview, 0, 0, LV_DIR_RIGHT);
    // 'do' is null, no properties or children for tile_obj_0 here.

    // "//": "Second WITH (tile2)"
    /* Second WITH (tile2) */
    // 'with.obj' is a call: lv_tileview_add_tile(main_tileview, 0, 0, LV_DIR_RIGHT)
    lv_obj_t* tile_obj_1 = lv_tileview_add_tile(main_tileview, 0, 0, LV_DIR_RIGHT);
    // "do" for second "with" (on tile_obj_1):
    // "//": "Second DO on tile2"
    /* Second DO on tile2 */
    lv_obj_add_style(tile_obj_1, style_0, 0);
    lv_obj_set_style_bg_color(tile_obj_1, lv_color_hex(0xff0000), 0);
    lv_obj_set_style_bg_opa(tile_obj_1, LV_OPA_COVER, 0);
    // Children of second "with.do", parented to tile_obj_1:
    {
        lv_obj_t* label_on_tile2 = lv_label_create(tile_obj_1);
        registry_add_generated_var(ui_registry, "label_on_tile2", "label_on_tile2");
        // registry_add_pointer(ui_registry, label_on_tile2, "label_on_tile2", "label");
        lv_obj_center(label_on_tile2);
        lv_label_set_text(label_on_tile2, "Scroll right");
    }

    // "//": "Third WITH (tile3)"
    /* Third WITH (tile3) */
    // 'with.obj' is a call: lv_tileview_add_tile(main_tileview, 1, 0, LV_DIR_LEFT)
    lv_obj_t* tile_obj_2 = lv_tileview_add_tile(main_tileview, 1, 0, LV_DIR_LEFT);
    // "do" for third "with" (on tile_obj_2):
    // "//": "Third DO on tile3"
    /* Third DO on tile3 */
    lv_obj_add_style(tile_obj_2, style_0, 0);
    // Children of third "with.do", parented to tile_obj_2:
    {
        // Processing "use-view", "id": "@jog_view", "named": "jog_view_on_tile3"
        // process_node_internal for "use-view" with forced_c_var_name = "jog_view_on_tile3"
        // The component @jog_view has a root that is a basic object.
        lv_obj_t* jog_view_on_tile3 = lv_obj_create(tile_obj_2);
        registry_add_generated_var(ui_registry, "jog_view_on_tile3", "jog_view_on_tile3");
        // registry_add_pointer(ui_registry, jog_view_on_tile3, "jog_view_on_tile3", "obj"); // Assuming base type "obj" for component root

        // Applying properties from @jog_view's root to jog_view_on_tile3
        lv_obj_set_style_bg_color(jog_view_on_tile3, lv_color_hex(0x00ff00), 0);
        lv_obj_set_size(jog_view_on_tile3, lv_pct(100), lv_pct(100));
        // Children of @jog_view's root, parented to jog_view_on_tile3
        {
            // This label does not have an id or name, so it gets a generated one like label_0 or label_1
            // (depending on var_counter state)
            lv_obj_t* label_1 = lv_label_create(jog_view_on_tile3);
            lv_label_set_text(label_1, "TEST");
        }
    }
}
