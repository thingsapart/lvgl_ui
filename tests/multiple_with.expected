#include "lvgl.h"
#include <stdio.h> // For NULL if not already included

// Assume another_label is declared globally or passed appropriately
// lv_obj_t* another_label;

lv_obj_t* my_label;

// Function to set up the UI elements
void setup_ui(lv_obj_t* parent_obj) {
    // Main object creation for "my_label"
    my_label = lv_label_create(parent_obj);

    // Add to pointer registry for "@my_label"
    // Assuming ui_registry is the global registry instance name
    registry_add_pointer(ui_registry, my_label, "my_label", "label");

    // Properties for my_label (from "properties" sub-object) are processed by
    // the call to process_properties within process_node_internal's main logic for the node.
    lv_label_set_text(my_label, "Main Label Text");

    // Then, the iterative loop at the end of process_node_internal (for regular nodes)
    // will process the top-level "with" blocks.

    // First 'with' block
    // obj_expr is a call, so a new temp var (e.g. label_0 or obj_0) is created.
    lv_obj_t* label_0 = lv_label_create(parent_obj);
    lv_label_set_text(label_0, "First With");

    // Second 'with' block
    // obj_expr is a call, so a new temp var (e.g. obj_1) is created.
    lv_obj_t* obj_1 = lv_obj_get_child(parent_obj, 0);
    lv_obj_set_align(obj_1, LV_ALIGN_CENTER);

    // Third 'with' block
    // obj_expr is "@another_label", so it operates directly on 'another_label'.
    // (Assuming another_label is properly declared and initialized elsewhere).
    lv_label_set_text(another_label, "Third With");
}

/*
// Minimal main for testing if needed
int main(void) {
    lv_init();
    // Dummy screen
    lv_obj_t* screen = lv_obj_create(NULL);
    lv_disp_load_scr(screen);

    // Dummy another_label for the test case
    another_label = lv_label_create(screen);
    // Initialize ui_registry if it's a pointer that needs allocation
    // ui_registry = registry_create();

    setup_ui(screen); // Pass screen as parent_obj

    // while(1) {
    //     lv_timer_handler();
    //     // usleep(5000);
    // }
    // if (ui_registry) registry_free(ui_registry);
    return 0;
}
*/
