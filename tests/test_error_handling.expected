ERROR: "LV_IMAGE_FLAGS_MODIFIABLE" (enum _lvimage_flags_t) is not of expected enum type lv_align_t.
ERROR: "LV_IMAGE_FLAGS_MODIFIABLE" (enum _lvimage_flags_t) is not of expected enum type lv_flex_align_t.
Warning: Property 'align_y' for object type 'obj' (C var 'error_test_obj') not found in API spec. Skipping.
Warning: Property 'text_decor' (simple setter) received an array value. This is typically for multi-arg setters. Argument count check might be unreliable.
ERROR: Property 'text_decor' on object type 'obj' (setter lv_obj_set_style_text_decor) expects a single value, but JSON provided 2 effective argument(s).
ERROR: Property 'flex_align_too_few' on object type 'obj' (setter lv_obj_set_flex_align) expects 3 value argument(s), but 2 provided in JSON.
ERROR: Property 'flex_align_too_many' on object type 'obj' (setter lv_obj_set_flex_align) expects 3 value argument(s), but 4 provided in JSON.
Warning: Property 'width_array_error' (simple setter) received an array value. This is typically for multi-arg setters. Argument count check might be unreliable.
ERROR: Property 'width_array_error' on object type 'obj' (setter lv_obj_set_width) expects a single value, but JSON provided 2 effective argument(s).
Warning: Property 'non_existent_prop_on_obj' for object type 'obj' (C var 'error_test_obj') not found in API spec. Skipping.
Warning: Property 'style_a_made_up_prop_on_obj' for object type 'obj' (C var 'error_test_obj') not found in API spec. Skipping.
Warning: Unhandled JSON object structure in unmarshal_value. Object was: {"unhandled_call_key_for_x":"some_func"}
Warning: Unhandled JSON object structure in unmarshal_value. Object was: {"nested_object_for_y":10}
// --- Standard includes ---
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "lvgl.h"
#include "ui_helpers.h"
#include "ui_registry.h"

// --- Global string literals ---

// --- UI Object Function Declarations ---
void ui_error_test_obj_create(lv_obj_t* parent);
void ui_error_test_style_var_create(lv_style_t* style);

// --- Custom LVGL object types ---

// --- UI Object Function Definitions ---
void ui_error_test_obj_create(lv_obj_t* parent) {
    lv_obj_t* error_test_obj = lv_obj_create(parent);
    lv_obj_set_size(error_test_obj, LV_PCT(100), LV_PCT(100));
    // Test Case 1: Enum Type Mismatch - Simple Property (obj.align expects lv_align_t)
    lv_obj_set_align(error_test_obj, LV_IMAGE_FLAGS_MODIFIABLE);
    // Test Case 3: Enum Type Mismatch - func_args (obj.flex_align expects 3x lv_flex_align_t)
    lv_obj_set_flex_align(error_test_obj, LV_FLEX_ALIGN_CENTER, LV_IMAGE_FLAGS_MODIFIABLE, LV_FLEX_ALIGN_END);
    // Test Case 4: Enum Type Mismatch - Invalid string for enum (obj.align_y expects lv_align_t)
    // align_y is processed by lv_obj_set_style_align_y if no direct setter.
    // If `align_y` is not found, it's skipped (as covered by the warning).
    // Assuming align_y is defined in api_spec.json for obj:
    // lv_obj_set_align_y(error_test_obj, "NOT_AN_ENUM_VALUE_AT_ALL"); // This call might not happen if prop not found
    // Actually, obj.align_y setter is lv_obj_set_style_align_y, expects lv_align_t, num_style_args = 0
    // So it will be:
    lv_obj_set_style_align_y(error_test_obj, "NOT_AN_ENUM_VALUE_AT_ALL", LV_PART_MAIN | LV_STATE_DEFAULT);

    // Test Case 5: Argument Count Mismatch - Simple Setter - Array given to single value prop (obj.text_decor)
    lv_obj_set_style_text_decor(error_test_obj, LV_TEXT_DECOR_UNDERLINE, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Test Case 6.1: Argument Count Mismatch - func_args - Too Few (obj.flex_align)
    lv_obj_set_flex_align(error_test_obj, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, NULL);
    // Test Case 6.2: Argument Count Mismatch - func_args - Too Many (obj.flex_align)
    lv_obj_set_flex_align(error_test_obj, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_END);
    // Test Case 7: Argument Count Mismatch - Simple Setter - Array given (obj.width)
    lv_obj_set_width(error_test_obj, 100);
    // Test Case 8: Default Selector Usage - Simple value (obj.border_width, num_style_args: -1)
    lv_obj_set_style_border_width(error_test_obj, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Test Case 9: Default Selector Usage - Explicit part, default state (obj.border_color, num_style_args: -1)
    lv_obj_set_style_border_color(error_test_obj, lv_color_hex(0xFF0000), LV_PART_SCROLLBAR | LV_STATE_DEFAULT);
    // Test Case 10: Default Selector Usage - Explicit state, default part (obj.outline_width, num_style_args: -1)
    lv_obj_set_style_outline_width(error_test_obj, 2, LV_PART_MAIN | LV_STATE_FOCUSED);
    // Test Case 11: Correct enum for simple property (obj.align)
    lv_obj_set_align(error_test_obj, LV_ALIGN_CENTER);
    // Test Case 12: Correct enum for func_args (obj.flex_align)
    lv_obj_set_flex_align(error_test_obj, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_END);
    // Test Case 14: Correct arg count for simple setter (single value - obj.height)
    lv_obj_set_height(error_test_obj, 150);
    // Test Case 15: Correct arg count for simple setter (value/part/state object - obj.border_opa)
    lv_obj_set_style_border_opa(error_test_obj, LV_OPA_50, LV_PART_INDICATOR | LV_STATE_CHECKED);
    // Test Case 19: Unhandled JSON object structure in unmarshal_value (obj.x)
    lv_obj_set_x(error_test_obj, NULL);
    // Test Case 20: Unhandled JSON type in unmarshal_value (obj.y)
    lv_obj_set_y(error_test_obj, NULL);
    registry_add_pointer(&ui_registry_get_default()->registry, error_test_obj, "error_test_obj", "obj");
}

void ui_error_test_style_var_create(lv_style_t* style) {
    lv_style_init(style);
    // Test Case 21: Style property, default selector (style.text_opa, num_style_args: 1, expects state+value)
    lv_style_set_text_opa(style, LV_STATE_DEFAULT, LV_OPA_70);
    // Test Case 22: Style property, explicit state (style.text_color, num_style_args: 1, expects state+value)
    lv_style_set_text_color(style, LV_STATE_HOVERED, lv_color_hex(0x123456));
    registry_add_generated_var(&ui_registry_get_default()->registry, "error_test_style", "error_test_style_var");
}

//stderr_eof
//stdout_eof
// Note: The stderr_eof and stdout_eof might not be strictly necessary for the diff tool used in run_tests.sh,
// but it's a good practice to delineate where stderr output is expected to end.
// The actual run_tests.sh captures combined output, so the order matters.
// I've placed the expected stderr messages at the top for easier review here, but
// in reality, they'd be interleaved with generator's info/warning messages about skipping props etc.
// The most important thing is that these messages *are present* in the output.
// The exact C code for error cases might be slightly different if unmarshal_value returns specific error objects
// that codegen then handles, rather than just NULL or the first element of an array.
// For example, for an array passed to a simple setter, if unmarshal_value returns an IR_EXPR_ARRAY,
// and codegen_expr then tries to render it as a simple value, it might print "{val1, val2}" or just val1.
// The current error checks should prevent most of these from reaching codegen in a problematic state.
// The `align_y` case: `obj.align_y` uses `lv_obj_set_style_align_y`. This expects `(obj, value, selector)`.
// `num_style_args` for `align_y` on `obj` is 0. This means it expects a value, and part/state are added.
// So, `lv_obj_set_style_align_y(error_test_obj, "NOT_AN_ENUM_VALUE_AT_ALL", LV_PART_MAIN | LV_STATE_DEFAULT)` is correct.
// The enum error for "NOT_AN_ENUM_VALUE_AT_ALL" vs "lv_align_t" will be triggered by unmarshal_value.

```
